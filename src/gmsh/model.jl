type Point
    x::Float64
    y::Float64
    z::Float64
    lc::Float64
    id::Int
end

type Line
    p1::Point
    p2::Point
    transfinite::Union{Int,Tuple{Int,String,Real}}
    id::Int
end

type LineLoop
    lines::Vector{Line}
    flip::BitArray{1}
    id::Int
end

type Surface
    lineloops::Vector{LineLoop}
    id::Int
end

type PhysicalSurface
    label::String
    surfaces::Vector{Surface}
    id::Int
end

type Model
    points::Vector{Point}
    lines::Vector{Line}
    lineloops::Vector{LineLoop}
    surfaces::Vector{Surface}
    physsurf::Vector{PhysicalSurface}
    opts::Vector{String} # Meshing options
    id::Int # Global ID to keep track of objects
    function Model(;recombineall=false)
        opts = Vector{String}(0)
        recombineall && push!(opts,"Mesh.RecombineAll = 1;")
        return new(Vector{Point}(0),Vector{Line}(0),Vector{LineLoop}(0),Vector{Surface}(0),Vector{PhysicalSurface}(0),opts,0)
    end
end

function add_point!(m::Model,x,y,z,lc=0.)
    # Make sure point does not already exist in model
    i = find(p->p.x==x&&p.y==y&&p.z==z,m.points)
    if isempty(i)
        o = Point(x,y,z,lc,m.id+=1)
        push!(m.points,o)
    else
        o = m.points[i[1]]
        o.lc = lc
    end
    return o
end

function get_points(ll::LineLoop)
    p = Vector{Point}(length(ll.lines))
    for (i,l) in enumerate(ll.lines)
        p[i] = l.p1
    end
    return p
end

function add_line!(m::Model,p1::Point,p2::Point,transfinite::Union{Int,Tuple{Int,String,Real}}=0)
    o = Line(p1,p2,transfinite,m.id+=1)
    push!(m.lines,o)
    return o
end

function add_lineloop!(m::Model,lines::Vector{Line},flip::BitArray{1}=falses(length(lines)))
    o = LineLoop(lines,flip,m.id+=1)
    push!(m.lineloops,o)
    return o
end

function add_surface!(m::Model,ll::Union{LineLoop,Vector{LineLoop}})
    o = Surface([ll;],m.id+=1)
    push!(m.surfaces,o)
    return o
end

function add_physicalsurf!(m::Model,label::String,sf::Union{Surface,Vector{Surface}})
    # If a physical surface with the same label already exists, add to it
    i = find(p->p.label==label,m.physsurf)
    if isempty(i)
        o = PhysicalSurface(label,[sf;],m.id+=1)
        push!(m.physsurf,o)
    else
        o = m.physsurf[i[1]]
        push!(m.physsurf.surfaces,[sf;])
    end
    return o
end

function duplicate!(m::Model,p::Point,t::Tuple{Real,Real,Real})
    return add_point!(m,p.x+t[1],p.y+t[2],p.z+t[3],p.lc)
end

function duplicate!(m::Model,l::Line,t::Tuple{Real,Real,Real})
    p1_new = duplicate!(m,l.p1,t)
    p2_new = duplicate!(m,l.p2,t)
    return add_line!(m,p1_new,p2_new,l.transfinite)
end

function duplicate!(m::Model,ll::LineLoop,t::Tuple{Real,Real,Real})
    lines = duplicate!.([m],ll.lines,[t])
    return add_lineloop!(m,lines)
end

function duplicate!(m::Model,s::Surface,t::Tuple{Real,Real,Real})
    ll = duplicate!.([m],s.lineloops,[t])
    return add_surface!(m,ll)
end

function extrude!(m::Model,s1::Surface,t::Tuple{Real,Real,Real};transfinite::Union{Int,Tuple{Int,String,Real}}=0)
    # First duplicate the surface (including any holes)
    s2 = duplicate!(m,s1,t)
    ns = [s2;]
    num_ll = length(s1.lineloops)
    flip = BitArray{1}([false,false,true,true])
    # For each lineloop
    for i = 1:num_ll
        num_vert = length(s1.lineloops[i].lines)
        line = Vector{Line}(num_vert)
        ll1 = s1.lineloops[i] # "Bottom"
        ll2 = s2.lineloops[i] # "Top"
        # Find matching vertices and join them with lines
        for j = 1:num_vert
            line[j] = add_line!(m,ll1.lines[j].p1,ll2.lines[j].p1,transfinite)
        end
        # Form new surfaces for each face, using the lines we just made
        for j = 1:num_vert
            ll = add_lineloop!(m,[ll1.lines[j],circshift(line,-1)[j],ll2.lines[j],line[j]],flip)
            push!(ns,add_surface!(m,ll))
        end
    end
    return ns
end

function print_geo_file(m::Model)
    title = "// File generated by Gmsh.jl"
    opts  = m.opts
    body  = mapreduce(vcat,fieldnames(m)[1:end-2]) do field
        mapreduce(print_object,vcat,getfield(m,field))
    end
    return join([title;opts;body],NL)
end

function print_object(o::Point)
    a = "o$(o.id) = newp;"
    b = "Point(o$(o.id)) = {$(o.x), $(o.y), $(o.z)$(o.lc==0.?"};":" , $(o.lc)};")"
    return join([a,b],NL)
end

function print_object(o::Line)
    a = "o$(o.id) = newl;"
    b = "Line(o$(o.id)) = {o$(o.p1.id), o$(o.p2.id)};"
    if o.transfinite==0
        return join([a,b],NL)
    else
        t = o.transfinite
        c = "Transfinite Line{o$(o.id)} = $(isa(t,Int)?"$t":"$(t[1]) Using $(t[2]) $(t[3])");"
        return join([a,b,c],NL)
    end
end

function print_object(o::LineLoop)
    a = "o$(o.id) = newll;"
    linelist = [(o.flip[i]?"-":"")*"o$(o.lines[i].id)" for i=1:length(o.lines)]
    b = "Line Loop(o$(o.id)) = {$(join(linelist,", "))};"
    return join([a,b],NL)
end

function print_object(o::Surface)
    a = "o$(o.id) = news;"
    b = "Plane Surface(o$(o.id)) = {$(join(["o$(ll.id)" for ll in o.lineloops],", "))};"
    if any(getfield.(o.lineloops[1].lines,[:transfinite]).!=0)
        c = "Transfinite Surface{o$(o.id)};"
        return join([a,b,c],NL)
    else
        return join([a,b],NL)
    end
end

function print_object(o::PhysicalSurface)
    a = "Physical Surface(\"$(o.label)\") = {$(join(["o$(s.id)" for s in o.surfaces],", "))};"
    return a
end
